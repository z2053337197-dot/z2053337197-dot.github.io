<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>è‹±è¯­ç¿»ç‰Œé…å¯¹ åŠ æ²¹æ¯ä¸€å¤©</title>
  <style>
    :root { --bg:#0b0d12; --card:#141826; --card2:#0f1320; --txt:#e9eefc; --mut:#9aa6c2; --ok:#28d17c; --bad:#ff5c7a; --line:#222943; }
    *{box-sizing:border-box;font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, PingFang SC, Microsoft YaHei, Arial;}
    body{margin:0; background:linear-gradient(180deg,#0b0d12,#0b0d12 40%,#080a10); color:var(--txt); min-height:100vh;}
    .wrap{max-width:980px; margin:0 auto; padding:20px;}
.topbar{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
  margin-bottom:10px;
}

.topbar h1{ margin:0; }

#audioControls{
  display:flex;
  align-items:center;
  justify-content:flex-end;
  gap:8px;
  flex-wrap:wrap;
}

#audioControls input[type="range"]{
  width:110px;
}

    h1{font-size:20px; margin:0 0 14px;}
    .tabs{display:flex; gap:10px; margin-bottom:14px;}
    .tab{padding:10px 12px; border:1px solid var(--line); background:rgba(255,255,255,0.02); color:var(--txt); border-radius:12px; cursor:pointer;}
    .tab.active{border-color:#3b4a7a; background:rgba(120,160,255,0.10);}
    .panel{border:1px solid var(--line); background:rgba(255,255,255,0.03); border-radius:16px; padding:16px;}
    .row{display:flex; gap:12px; flex-wrap:wrap; align-items:center;}
    label{font-size:12px; color:var(--mut);}
    input, select, textarea, button{
      border:1px solid var(--line); border-radius:12px; background:rgba(255,255,255,0.04);
      color:var(--txt); padding:10px 12px; outline:none;
    }
    textarea{width:100%; min-height:160px; resize:vertical; line-height:1.5;}
    button{cursor:pointer;}
    button.primary{background:rgba(120,160,255,0.18); border-color:#3b4a7a;}
    button.danger{background:rgba(255,92,122,0.15); border-color:#6a2a3a;}
    .hint{font-size:12px; color:var(--mut); margin-top:8px; line-height:1.6;}
    .grid{
      display:grid; gap:12px; margin-top:14px;
      grid-template-columns: repeat(4, minmax(0,1fr));
    }
    .card{
      background:linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
      border:1px solid var(--line);
      border-radius:16px; min-height:86px;
      display:flex; align-items:center; justify-content:center;
      padding:10px;
      user-select:none;
      cursor:pointer;
      transition:transform .08s ease, border-color .2s ease, background .2s ease;
    }
    .card:active{transform:scale(0.99);}
    .card.faceDown{
      background:linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.01));
    }
    .card.matched{
      border-color:rgba(40,209,124,0.55);
      background:rgba(40,209,124,0.10);
      cursor:default;
    }
    .cardText{font-size:14px; text-align:center; line-height:1.25; word-break:break-word;}
    .meta{display:flex; gap:14px; margin-top:10px; color:var(--mut); font-size:12px;}
    .pill{border:1px solid var(--line); padding:6px 10px; border-radius:999px; background:rgba(255,255,255,0.03);}
    .toast{margin-top:10px; font-size:12px;}
    .toast.ok{color:var(--ok);}
    .toast.bad{color:var(--bad);}
    .footerBtns{display:flex; gap:10px; flex-wrap:wrap; margin-top:14px;}
    .hr{height:1px; background:var(--line); margin:14px 0;}
    .small{font-size:12px; color:var(--mut);}
    @media (max-width:560px){
      .grid{grid-template-columns: repeat(2, minmax(0,1fr));}
      .card{min-height:78px;}
    }
/* ===== THEME OVERRIDE (paste at END of <style>) ===== */
:root{
  /* å…¨å±€é…è‰²ï¼ˆä½ æƒ³æ¢è‰²ï¼Œå°±æ”¹è¿™é‡Œï¼‰ */
  --bgA: #0b1020;
  --bgB: #06243a;
  --text: #eaf2ff;
  --muted: rgba(234,242,255,.72);

  --surface: rgba(255,255,255,.07);
  --surface2: rgba(255,255,255,.10);

  --accent: #5eead4;
  --danger: #fb7185;
  --ok: #34d399;


  /* å¡ç‰ŒèƒŒé¢â€œå›¾ç‰‡â€ï¼ˆé»˜è®¤å†…ç½®ä¸€å¼ å‡ ä½•å›¾æ¡ˆï¼Œä¸ç”¨é¢å¤–æ–‡ä»¶ï¼‰ */
  --card-back-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='320' height='320'%3E%3Cdefs%3E%3CradialGradient id='g' cx='30%25' cy='20%25' r='80%25'%3E%3Cstop offset='0' stop-color='%235eead4' stop-opacity='.55'/%3E%3Cstop offset='1' stop-color='%230b1020' stop-opacity='1'/%3E%3C/radialGradient%3E%3Cpattern id='p' width='40' height='40' patternUnits='userSpaceOnUse'%3E%3Cpath d='M0 20H40M20 0V40' stroke='%23eaf2ff' stroke-opacity='.12' stroke-width='2'/%3E%3C/pattern%3E%3C/defs%3E%3Crect width='320' height='320' fill='url(%23g)'/%3E%3Crect width='320' height='320' fill='url(%23p)'/%3E%3Ccircle cx='250' cy='70' r='46' fill='%23ffffff' fill-opacity='.08'/%3E%3Ccircle cx='80' cy='240' r='68' fill='%23ffffff' fill-opacity='.06'/%3E%3C/svg%3E");
}

body{
  color: var(--text);
  background:
    radial-gradient(900px 600px at 20% 10%, rgba(94,234,212,.22), transparent 55%),
    radial-gradient(900px 700px at 85% 20%, rgba(59,130,246,.18), transparent 55%),
    linear-gradient(160deg, var(--bgA), var(--bgB));
}

.wrap{
  max-width: 980px;
}

.panel, .toast{
  background: var(--surface);
  border: 1px solid rgba(255,255,255,.10);
  border-radius: var(--radius);
  box-shadow: var(--shadow);
}

.small, label{
  color: var(--muted);
}

.tabs button{
  background: transparent;
  border: 1px solid rgba(255,255,255,.12);
  color: var(--text);
  border-radius: 999px;
}
.tabs button.active{
  background: rgba(94,234,212,.16);
  border-color: rgba(94,234,212,.35);
}

button{
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,.14);
  background: rgba(255,255,255,.06);
  color: var(--text);
}
button:hover{ filter: brightness(1.06); }
button.primary{
  background: rgba(94,234,212,.18);
  border-color: rgba(94,234,212,.40);
}
button.danger{
  background: rgba(251,113,133,.15);
  border-color: rgba(251,113,133,.35);
}

.pill{
  background: rgba(255,255,255,.06);
  border: 1px solid rgba(255,255,255,.10);
  border-radius: 999px;
  color: var(--text);
}

.grid{
  gap: 10px;
}

/* ===== å¡ç‰Œæ ·å¼ï¼šèƒŒé¢ç”¨â€œå›¾ç‰‡â€ï¼Œæ­£é¢æ›´æ¸…çˆ½ ===== */
.card{
  position: relative;
  border-radius: 16px;
  border: 1px solid rgba(255,255,255,.14);
  background: rgba(255,255,255,.06);
  box-shadow: 0 10px 20px rgba(0,0,0,.22);
  transform: translateZ(0);
  transition: transform .12s ease, filter .12s ease;
}

.card:hover{ transform: translateY(-2px); }

/* ç›–ç€æ—¶ï¼šéšè—æ–‡å­—ï¼Œæ˜¾ç¤ºèƒŒé¢å›¾æ¡ˆ */
/* ç›–ç€æ—¶ï¼šéšè—æ–‡å­—ï¼Œæ˜¾ç¤ºèƒŒé¢å›¾æ¡ˆï¼ˆç”¨ faceDown è¡¨ç¤ºç›–ç€ï¼‰ */
.card.faceDown{
  color: transparent; /* æŠŠâ€¢â€¢â€¢å’Œæ–‡å­—éƒ½éšè— */
  text-shadow: none;
}
.card.faceDown::before{
  content:"";
  position:absolute;
  inset:0;
  border-radius: 16px;
  background-image: var(--card-back-image);
  background-size: cover;
  background-position: center;
  filter: saturate(1.1) contrast(1.05);
}

/* ç¿»å¼€æˆ–åŒ¹é…ï¼šä¸æ˜¾ç¤ºèƒŒé¢å›¾æ¡ˆ */
.card:not(.faceDown)::before,
.card.matched::before{
  content:"";
  display:none;
}

/* ç¿»å¼€çŠ¶æ€ï¼ˆæ²¡æœ‰ faceDownï¼‰æ˜¾ç¤ºæ­£é¢ */
.card:not(.faceDown){
  background: rgba(255,255,255,.10);
  border-color: rgba(94,234,212,.30);
  color: var(--text);
}

/* åŒ¹é…çŠ¶æ€ */
.card.matched{
  background: rgba(52,211,153,.18);
  border-color: rgba(52,211,153,.40);
  color: var(--text);
}

.card.matched{
  background: rgba(52,211,153,.18);
  border-color: rgba(52,211,153,.40);
  color: var(--text);
}
/* ===== ä¿®å¤ä¸‹æ‹‰æ¡†ï¼ˆselect/optionï¼‰ç™½åº•ç™½å­—çœ‹ä¸æ¸… ===== */
select{
  background: rgba(255,255,255,.08);
  color: var(--text);
  border: 1px solid rgba(255,255,255,.18);
  border-radius: 12px;
}

/* ä¸‹æ‹‰é€‰é¡¹åˆ—è¡¨ï¼ˆå…³é”®ï¼šoptionï¼‰ */
select option{
  background: #0b1020;   /* é€‰é¡¹åˆ—è¡¨èƒŒæ™¯ï¼ˆæ·±è‰²ï¼‰ */
  color: #eaf2ff;        /* é€‰é¡¹æ–‡å­—é¢œè‰²ï¼ˆæµ…è‰²ï¼‰ */
}

/* é€‰ä¸­/æ‚¬åœæ—¶ï¼ˆä¸åŒæµè§ˆå™¨æ”¯æŒä¸ä¸€ï¼Œä½†å†™äº†æ›´ç¨³ï¼‰ */
select option:checked{
  background: #162341;
  color: #eaf2ff;
}

  </style>


</head>
<body>
  <div class="wrap">
    <div class="topbar">
  <h1>è‹±è¯­ç¿»ç‰Œé…å¯¹ï¼ˆåŠ æ²¹æ¯ä¸€å¤©ï¼‰</h1>

  <div id="audioControls">
    <button id="btnMusic">ğŸ”‡ éŸ³ä¹ï¼šå…³</button>
    <input id="musicVol" type="range" min="0" max="1" step="0.01" value="0.35" />

    <button id="btnSfx">ğŸ”ˆ éŸ³æ•ˆï¼šå¼€</button>
    <input id="sfxVol" type="range" min="0" max="1" step="0.01" value="0.6" />
  </div>
</div>


    <div class="tabs">
      <button class="tab active" id="tabPlay">å¼€å§‹æ¸¸æˆ</button>
      <button class="tab" id="tabVocab">è¯åº“å¯¼å…¥</button>
    </div>

    <!-- PLAY PANEL -->
    <div class="panel" id="playPanel">
      <div class="row" style="justify-content:space-between;">
        <div class="row">
          <div>
            <label>é€‰æ‹©è¯åº“</label><br/>
            <select id="vocabSelect"></select>
          </div>
          <div>
            <label>éš¾åº¦</label><br/>
            <select id="difficulty">
              <option value="easy">ç®€å•ï¼ˆ4å¯¹ / 2Ã—4ï¼‰</option>
              <option value="normal">ä¸€èˆ¬ï¼ˆ8å¯¹ / 4Ã—4ï¼‰</option>
              <option value="hard">å›°éš¾ï¼ˆ18å¯¹ / 6Ã—6ï¼‰</option>
            </select>
          </div>
        </div>
        <div class="row">
          <button class="primary" id="btnStart">å¼€å§‹</button>
          <button id="btnRestart">é‡å¼€æœ¬å±€</button>
        </div>
      </div>

      <div class="meta">
	<div class="pill">æœ¬å±€ç”¨æ—¶ï¼š<span id="timeText">0</span>s</div>
	<div class="pill">æœ¬å±€æ­¥æ•°ï¼š<span id="movesText">0</span></div>
	<div class="pill">æœ¬å±€å·²é…å¯¹ï¼š<span id="matchText">0</span>/<span id="totalPairsText">0</span></div>
	<div class="pill">ç´¯è®¡é…å¯¹ï¼š<span id="cumPairsText">0</span> å¯¹</div>
	<div class="pill">ç´¯è®¡ç§¯åˆ†ï¼š<span id="scoreText">0</span></div>
	<div class="pill">ç´¯è®¡ç”¨æ—¶ï¼š<span id="cumTimeText">0</span></div>
      </div>

      <div class="toast" id="statusText"></div>

      <div class="grid" id="grid"></div>

      <div class="footerBtns">
        <button id="btnBackToMenu">ç»“ç®—æœ¬å±€</button>
      </div>

      <div class="hint">
        ç©æ³•ï¼šä¸€æ¬¡æœ€å¤šç¿»ä¸¤å¼ ï¼›åŒä¸€å¯¹ï¼ˆè‹±æ–‡â†”ä¸­æ–‡ï¼‰ä¼šé”å®šï¼›é…å®Œæ‰€æœ‰å¯¹æ•°ç»“æŸã€‚<br/>
        è¯åº“ä¸è¶³æ—¶ä¼šè‡ªåŠ¨é™çº§ï¼šæ¯”å¦‚ä½ åªå¯¼å…¥äº† 5 å¯¹ï¼Œä½†é€‰æ‹©â€œä¸€èˆ¬(8å¯¹)â€ä¼šè‡ªåŠ¨å˜ä¸º 5 å¯¹å±€ã€‚
      </div>
    </div>

    <!-- VOCAB PANEL -->
    <div class="panel" id="vocabPanel" style="display:none;">
      <div class="row">
        <div style="flex:1; min-width:240px;">
          <label>è¯åº“åç§°ï¼ˆè‡ªå®šä¹‰ï¼‰</label><br/>
          <div class="row" style="gap:10px; flex-wrap:wrap;">
  <select id="setSelect" style="min-width:220px;">
    <option value="__new__">+ æ–°å»ºè¯åº“</option>
  </select>
  <input id="setName" placeholder="æ–°å»ºæ—¶åœ¨è¿™é‡Œè¾“å…¥åç§°ï¼Œä¾‹å¦‚ï¼šé¤å… / ç§Ÿæˆ¿ / é¢è¯•" style="flex:1; min-width:240px;" />
</div>

        </div>
        <div class="row" style="align-items:flex-end;">
          <button class="primary" id="btnSaveSet">ä¿å­˜/è¦†ç›–è¯åº“</button>
          <button class="danger" id="btnDeleteSet">åˆ é™¤è¯¥è¯åº“</button>
	<div class="toast" id="vocabStatusText"></div>
        </div>
      </div>

      <div class="hr"></div>

      <label>æ‰¹é‡å¯¼å…¥ï¼ˆæ¯è¡Œä¸€å¯¹ï¼‰</label>
      <textarea id="importBox" placeholder="ä¾‹å¦‚ï¼š
apple - è‹¹æœ
rent	ç§Ÿé‡‘
make a reservation - é¢„è®¢
Iâ€™m looking for a job - æˆ‘åœ¨æ‰¾å·¥ä½œ"></textarea>
      <div class="row" style="margin-top:10px;">
        <input id="csvFile" type="file" accept=".csv,text/csv" />
        <button id="btnLoadCsv">è¯»å–CSVåˆ°å¯¼å…¥æ¡†</button>
        <span class="small">CSV ä¸¤åˆ—ï¼šen,zhï¼ˆå¯æœ‰è¡¨å¤´ï¼‰</span>
      </div>

      <div class="hr"></div>

      <label>å¤‡ä»½ / åˆ†äº«</label>
      <div class="row" style="margin-top:10px;">
        <button id="btnExportAllJson">å¯¼å‡ºå…¨éƒ¨è‡ªå®šä¹‰è¯åº“ï¼ˆJSONï¼‰</button>
        <button id="btnExportCurrentTxt">å¯¼å‡ºå½“å‰è¯åº“ï¼ˆTXTï¼‰</button>
        <button class="primary" id="btnCopyExport">å¤åˆ¶å¯¼å‡ºå†…å®¹</button>
      </div>

      <textarea id="exportBox" placeholder="å¯¼å‡ºå†…å®¹ä¼šæ˜¾ç¤ºåœ¨è¿™é‡Œï¼ˆå¯å¤åˆ¶å‘é€ç»™åˆ«äººï¼‰" readonly></textarea>

      <div class="hr"></div>

      <label>å¯¼å…¥ï¼ˆç²˜è´´ä½ çš„ JSONï¼‰</label>
      <textarea id="importShareBox" placeholder='æŠŠJSON ç²˜è´´åˆ°è¿™é‡Œï¼Œä¾‹å¦‚ï¼š
{
  "version": 1,
  "sets": {
    "ç§Ÿæˆ¿": [{"en":"rent","zh":"ç§Ÿé‡‘"}]
  }
}'></textarea>
      <div class="row" style="margin-top:10px;">
        <button class="primary" id="btnImportShare">å¯¼å…¥å¹¶è¦†ç›–è‡ªå®šä¹‰è¯åº“</button>
      </div>


      <div class="row" style="margin-top:10px;">
        <button id="btnParsePreview">è§£æé¢„è§ˆ</button>
        <button id="btnUseSample">å¡«å…¥ç¤ºä¾‹æ•°æ®</button>
        <span class="small" id="previewText"></span>
      </div>

      <div class="hint">
        æ”¯æŒä¸¤ç§æ ¼å¼ï¼š<br/>
        1ï¼‰<b>è‹±æ–‡ - ä¸­æ–‡</b>ï¼ˆä¸­é—´å»ºè®®æœ‰ç©ºæ ¼ï¼‰<br/>
        2ï¼‰<b>è‹±æ–‡[TAB]ä¸­æ–‡</b>ï¼ˆæ›´ç¨³ï¼Œä¸æ€•ä¸­æ–‡é‡Œæœ‰ç¬¦å·ï¼‰<br/>
        è‡ªåŠ¨å»é‡ï¼šè‹±æ–‡ç›¸åŒï¼ˆå¿½ç•¥å¤§å°å†™å’Œé¦–å°¾ç©ºæ ¼ï¼‰ä¼šä¿ç•™æœ€åä¸€æ¬¡å¯¼å…¥çš„é‚£æ¡ã€‚
      </div>
    </div>
  </div>

<script>
  // ---------- Storage ----------
  const LS_KEY = "mm_vocab_sets_v1";
  function loadSets() {
    try {
      const raw = localStorage.getItem(LS_KEY);
      if (!raw) return {};
      return JSON.parse(raw) || {};
    } catch { return {}; }
  }
  function saveSets(sets) {
    localStorage.setItem(LS_KEY, JSON.stringify(sets));
  }
 
  // ---------- Stats (cumulative) ----------
const STATS_KEY = "mm_stats_v1";

function loadStats() {
  try {
    const raw = localStorage.getItem(STATS_KEY);
    if (!raw) return { totalPairsMatched: 0, score: 0, totalTimeSeconds: 0 };
    const obj = JSON.parse(raw);
    return {
      totalPairsMatched: Number(obj.totalPairsMatched || 0),
      score: Number(obj.score || 0),
      totalTimeSeconds: Number(obj.totalTimeSeconds || 0),
    };
  } catch {
    return { totalPairsMatched: 0, score: 0, totalTimeSeconds: 0 };
  }
}

function saveStats(stats) {
  localStorage.setItem(STATS_KEY, JSON.stringify(stats));
}

let stats = loadStats();

function formatSeconds(sec) {
  sec = Math.max(0, Math.floor(sec));
  const h = String(Math.floor(sec / 3600)).padStart(2, "0");
  const m = String(Math.floor((sec % 3600) / 60)).padStart(2, "0");
  const s = String(sec % 60).padStart(2, "0");
  return `${h}:${m}:${s}`;
}

function renderStats() {
  if (cumPairsText) cumPairsText.textContent = String(stats.totalPairsMatched);
  if (scoreText) scoreText.textContent = String(stats.score);
  if (cumTimeText) cumTimeText.textContent = formatSeconds(stats.totalTimeSeconds);
}


  // ---------- Built-in vocab ----------
  const builtinPairs = [
    {en:"apple", zh:"è‹¹æœ"}, {en:"rent", zh:"ç§Ÿé‡‘"}, {en:"receipt", zh:"æ”¶æ®"}, {en:"kitchen", zh:"å¨æˆ¿"},
    {en:"menu", zh:"èœå•"}, {en:"reservation", zh:"é¢„è®¢"}, {en:"interview", zh:"é¢è¯•"}, {en:"salary", zh:"å·¥èµ„"},
    {en:"shift", zh:"ç­æ¬¡"}, {en:"laundry", zh:"æ´—è¡£åº—"}, {en:"deposit", zh:"æŠ¼é‡‘"}, {en:"invoice", zh:"å‘ç¥¨"},
    {en:"commute", zh:"é€šå‹¤"}, {en:"passport", zh:"æŠ¤ç…§"}, {en:"appointment", zh:"é¢„çº¦"}, {en:"overtime", zh:"åŠ ç­"},
    {en:"ingredient", zh:"é£Ÿæ"}, {en:"customer", zh:"é¡¾å®¢"}, {en:"refund", zh:"é€€æ¬¾"}, {en:"contract", zh:"åˆåŒ"},
    {en:"yangyongle", zh:"é’Ÿå‹‡"},

  ];

  // ---------- Parsing import text ----------
  function normalizeEn(s){ return s.trim().toLowerCase().replace(/\s+/g, " "); }
  function parsePairs(text){
    const lines = text.split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
    const outMap = new Map(); // key: normalized en -> {en,zh}
    const badLines = [];
    for (const line of lines){
      let en="", zh="";
      if (line.includes("\t")) {
        const parts = line.split("\t").map(x=>x.trim()).filter(Boolean);
        en = parts[0] || "";
        zh = parts.slice(1).join(" ") || "";
      } else if (line.includes(" - ")) {
        const idx = line.indexOf(" - ");
        en = line.slice(0, idx).trim();
        zh = line.slice(idx+3).trim();
      } else if (line.includes(",")) {
        // very simple CSV-ish: en,zh
        const parts = line.split(",").map(x=>x.trim());
        en = parts[0] || "";
        zh = parts.slice(1).join(",").trim() || "";
      } else {
        badLines.push(line);
        continue;
      }
      if (!en || !zh) { badLines.push(line); continue; }
      outMap.set(normalizeEn(en), {en: en.trim(), zh: zh.trim()});
    }
    return {pairs: Array.from(outMap.values()), badLines};
  }

  // ---------- UI refs ----------
  const tabPlay = document.getElementById("tabPlay");
  const tabVocab = document.getElementById("tabVocab");
  const playPanel = document.getElementById("playPanel");
  const vocabPanel = document.getElementById("vocabPanel");

  const vocabSelect = document.getElementById("vocabSelect");
  const difficulty = document.getElementById("difficulty");
  const btnStart = document.getElementById("btnStart");
  const btnRestart = document.getElementById("btnRestart");
  const btnBackToMenu = document.getElementById("btnBackToMenu");

  const gridEl = document.getElementById("grid");
  const timeText = document.getElementById("timeText");
  const movesText = document.getElementById("movesText");
  const matchText = document.getElementById("matchText");
  const totalPairsText = document.getElementById("totalPairsText");
  const statusText = document.getElementById("statusText");

  const setName = document.getElementById("setName");
  const importBox = document.getElementById("importBox");
  const btnParsePreview = document.getElementById("btnParsePreview");
  const btnUseSample = document.getElementById("btnUseSample");
  const btnSaveSet = document.getElementById("btnSaveSet");
  const btnDeleteSet = document.getElementById("btnDeleteSet");
  const previewText = document.getElementById("previewText");
  const vocabStatusText = document.getElementById("vocabStatusText");
  const setSelect = document.getElementById("setSelect");
  const cumTimeText = document.getElementById("cumTimeText");

const btnMusic = document.getElementById("btnMusic");
const musicVol = document.getElementById("musicVol");
const btnSfx = document.getElementById("btnSfx");
const sfxVol = document.getElementById("sfxVol");


  // --- stats refs ---
  const cumPairsText = document.getElementById("cumPairsText");
  const scoreText = document.getElementById("scoreText");

  // --- csv import refs ---
  const csvFile = document.getElementById("csvFile");
  const btnLoadCsv = document.getElementById("btnLoadCsv");

  // --- backup/share refs ---
  const btnExportAllJson = document.getElementById("btnExportAllJson");
  const btnExportCurrentTxt = document.getElementById("btnExportCurrentTxt");
  const btnCopyExport = document.getElementById("btnCopyExport");
  const exportBox = document.getElementById("exportBox");
  const importShareBox = document.getElementById("importShareBox");
  const btnImportShare = document.getElementById("btnImportShare");

// ---------- Audio ----------
const bgm = new Audio("bgm.mp3");
bgm.loop = true;
bgm.volume = 0.35;

let musicOn = false;
let sfxOn = true;
let sfxVolume = 0.6;

function updateAudioUI(){
  if (btnMusic) btnMusic.textContent = musicOn ? "ğŸ”Š éŸ³ä¹ï¼šå¼€" : "ğŸ”‡ éŸ³ä¹ï¼šå…³";
  if (btnSfx) btnSfx.textContent = sfxOn ? "ğŸ”ˆ éŸ³æ•ˆï¼šå¼€" : "ğŸ”‡ éŸ³æ•ˆï¼šå…³";
}

async function toggleMusic(){
  musicOn = !musicOn;
  updateAudioUI();

  if (musicOn){
    try{
      await bgm.play(); // å¿…é¡»ç”¨æˆ·ç‚¹å‡»åæ‰å…è®¸æ’­æ”¾
    }catch(e){
      musicOn = false;
      updateAudioUI();
      if (typeof setStatus === "function"){
        setStatus("éŸ³ä¹æ— æ³•æ’­æ”¾ï¼šè¯·ç¡®è®¤ bgm.mp3 ä¸æœ¬HTMLæ–‡ä»¶åŒä¸€æ–‡ä»¶å¤¹ï¼Œä¸”æ–‡ä»¶åä¸€è‡´ã€‚", "bad");
      }
    }
  }else{
    bgm.pause();
  }
}

function playSfx(filename){
  if (!sfxOn) return;
  try{
    const a = new Audio(filename);
    a.volume = sfxVolume;
    a.play().catch(()=>{});
  }catch(e){}
}

function toggleSfx(){
  sfxOn = !sfxOn;
  updateAudioUI();
}

if (btnMusic) btnMusic.onclick = toggleMusic;
if (btnSfx) btnSfx.onclick = toggleSfx;

if (musicVol){
  musicVol.oninput = () => {
    const v = Number(musicVol.value);
    bgm.volume = isNaN(v) ? 0.35 : v;
  };
}

if (sfxVol){
  sfxVol.oninput = () => {
    const v = Number(sfxVol.value);
    sfxVolume = isNaN(v) ? 0.6 : v;
  };
}

updateAudioUI();


  // ---------- App state ----------
  let sets = loadSets(); // { setName: [{en,zh}, ...] }
  const BUILTIN_NAME = "ï¼ˆå†…ç½®è¯åº“ï¼‰";
  let game = null;
  let timerId = null;

  function showTab(which){
    if (which === "play"){
      tabPlay.classList.add("active"); tabVocab.classList.remove("active");
      playPanel.style.display = ""; vocabPanel.style.display = "none";
    } else {
      tabVocab.classList.add("active"); tabPlay.classList.remove("active");
      vocabPanel.style.display = ""; playPanel.style.display = "none";
    }
  }
  tabPlay.onclick = ()=>showTab("play");
  tabVocab.onclick = ()=>showTab("vocab");

  function refreshVocabSelect(){
    vocabSelect.innerHTML = "";
    const optBuiltin = document.createElement("option");
    optBuiltin.value = "__builtin__";
    optBuiltin.textContent = BUILTIN_NAME;
    vocabSelect.appendChild(optBuiltin);

    const names = Object.keys(sets).sort((a,b)=>a.localeCompare(b,"zh"));
    for (const name of names){
      const opt = document.createElement("option");
      opt.value = name;
      opt.textContent = name + `ï¼ˆ${sets[name].length}å¯¹ï¼‰`;
      vocabSelect.appendChild(opt);
    }
  }
function refreshSetSelect() {
  if (!setSelect) return;

  const current = setSelect.value || "__new__";
  setSelect.innerHTML = "";

  // æ–°å»º
  const optNew = document.createElement("option");
  optNew.value = "__new__";
  optNew.textContent = "+ æ–°å»ºè¯åº“";
  setSelect.appendChild(optNew);

  // å·²æœ‰è¯åº“
  const names = Object.keys(sets).sort((a,b)=>a.localeCompare(b,"zh"));
  for (const name of names) {
    const opt = document.createElement("option");
    opt.value = name;
    opt.textContent = `${name}ï¼ˆ${sets[name].length}å¯¹ï¼‰`;
    setSelect.appendChild(opt);
  }

  // å°½é‡ä¿æŒä¹‹å‰é€‰æ‹©
  if ([...setSelect.options].some(o => o.value === current)) {
    setSelect.value = current;
  } else {
    setSelect.value = "__new__";
  }
}

// é€‰æ‹©æŸä¸ªè¯åº“åï¼ŒæŠŠå†…å®¹åŠ è½½åˆ°ç¼–è¾‘åŒº
if (setSelect) {
  setSelect.onchange = () => {
    const name = setSelect.value;
    if (name === "__new__") {
      setName.value = "";
      importBox.value = "";
      if (previewText) previewText.textContent = "";
      setStatus("å·²åˆ‡æ¢åˆ°ï¼šæ–°å»ºè¯åº“ã€‚è¾“å…¥åç§°å¹¶ç²˜è´´è¯å¯¹åä¿å­˜ã€‚", "ok");
      return;
    }

    // åŠ è½½å·²æœ‰è¯åº“åˆ°ç¼–è¾‘æ¡†
    setName.value = name;
    const arr = sets[name] || [];
    importBox.value = arr.map(p => `${p.en} - ${p.zh}`).join("\n");
    if (previewText) previewText.textContent = `å·²åŠ è½½ã€Œ${name}ã€ï¼š${arr.length} å¯¹`;
    setStatus(`å·²åŠ è½½è¯åº“ã€Œ${name}ã€ï¼Œç°åœ¨å¯ç›´æ¥ä¿®æ”¹åç‚¹ä¿å­˜è¦†ç›–ã€‚`, "ok");
  };
}

  refreshVocabSelect();

  // ---------- Difficulty params ----------
  const DIFF = {
    easy: { rows:2, cols:4, pairs:4 },
    normal:{ rows:4, cols:4, pairs:8 },
    hard:  { rows:6, cols:6, pairs:18 },
  };

  // ---------- Game helpers ----------
  function shuffle(arr){
    for (let i=arr.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [arr[i],arr[j]]=[arr[j],arr[i]];
    }
    return arr;
  }

  function stopTimer(){
    if (timerId) clearInterval(timerId);
    timerId = null;
  }

  function startTimer(){
    stopTimer();
    timerId = setInterval(()=>{
      if (!game || game.status!=="playing") return;
      const t = Math.floor((Date.now() - game.timeStart)/1000);
      timeText.textContent = String(t);
    }, 200);
  }
function setStatus(msg, type=""){
  // å¼€å§‹æ¸¸æˆé¡µæç¤º
  if (statusText){
    statusText.textContent = msg || "";
    statusText.className = "toast " + (type || "");
  }

  // è¯åº“å¯¼å…¥é¡µæç¤º
  if (vocabStatusText){
    vocabStatusText.textContent = msg || "";
    vocabStatusText.className = "toast " + (type || "");
  }
}


  function buildDeck(pairs){
    // pairs: [{en,zh}]
    const deck = [];
    pairs.forEach((p, idx)=>{
      const pairId = idx + 1;
      deck.push({id:`${pairId}-EN`, pairId, type:"EN", text:p.en, isFaceUp:false, isMatched:false});
      deck.push({id:`${pairId}-ZH`, pairId, type:"ZH", text:p.zh, isFaceUp:false, isMatched:false});
    });
    return shuffle(deck);
  }

  function renderGrid(){
    const {rows, cols} = game.layout;
    gridEl.style.gridTemplateColumns = `repeat(${cols}, minmax(0,1fr))`;
    gridEl.innerHTML = "";
    game.deck.forEach((card, index)=>{
      const el = document.createElement("div");
      el.className = "card " + (card.isFaceUp || card.isMatched ? "" : "faceDown") + (card.isMatched ? " matched" : "");
      el.dataset.index = String(index);
      const text = document.createElement("div");
      text.className = "cardText";
      text.textContent = (card.isFaceUp || card.isMatched) ? card.text : "â— â— â—";
      el.appendChild(text);
      el.onclick = ()=>onCardClick(index);
      gridEl.appendChild(el);
    });

    // pad if needed (shouldn't happen if rows*cols matches deck size)
    const totalSlots = rows*cols;
    for (let i=game.deck.length;i<totalSlots;i++){
      const pad = document.createElement("div");
      pad.className = "card faceDown";
      pad.style.opacity = "0.25";
      pad.innerHTML = `<div class="cardText">â€”</div>`;
      gridEl.appendChild(pad);
    }
  }

  function updateMeta(){
    movesText.textContent = String(game.moves);
    matchText.textContent = String(game.matches);
    totalPairsText.textContent = String(game.totalPairs);
  }

  function endGame(){
    game.status = "done";
    stopTimer();
    playSfx("win.mp3");
    addCurrentGameTimeToCumulative();
    const t = Math.floor((Date.now() - game.timeStart)/1000);
    setStatus(`å®Œæˆï¼ç”¨æ—¶ ${t}sï¼Œæ­¥æ•° ${game.moves}ã€‚`, "ok");
  }

function addCurrentGameTimeToCumulative() {
  if (!game || !game.timeStart) return;
  if (game.timeCounted) return; // é˜²æ­¢é‡å¤ç´¯åŠ 

  const elapsed = Math.floor((Date.now() - game.timeStart) / 1000);
  stats.totalTimeSeconds += Math.max(0, elapsed);
  saveStats(stats);
  renderStats();

  game.timeCounted = true;
}

  function resetPicks(){
    game.firstPick = null;
    game.secondPick = null;
  }

  function onCardClick(index){
    if (!game || game.status !== "playing") return;
    if (game.lockBoard) return;

    const c = game.deck[index];
    if (c.isMatched || c.isFaceUp) return;
playSfx("flip.mp3");

    c.isFaceUp = true;

    if (game.firstPick === null){
      game.firstPick = index;
      setStatus("");
      renderGrid();
      return;
    }

    // second pick
    game.secondPick = index;
    game.moves += 1;
    game.lockBoard = true;
    renderGrid();
    updateMeta();

    const a = game.deck[game.firstPick];
    const b = game.deck[game.secondPick];

    const isMatch = (a.pairId === b.pairId) && (a.type !== b.type);

    if (isMatch){
      a.isMatched = true; b.isMatched = true;
      game.matches += 1;
// ç´¯è®¡é…å¯¹ä¸ç´¯è®¡ç§¯åˆ†ï¼ˆæ¯å¯¹ +10 åˆ†ï¼‰
      stats.totalPairsMatched += 1;
      stats.score += 10;
      saveStats(stats);
      renderStats();
      setStatus("åŒ¹é…æˆåŠŸï¼", "ok");
      playSfx("match.mp3");
      game.lockBoard = false;
      resetPicks();
      renderGrid();
      updateMeta();
      if (game.matches === game.totalPairs) endGame();
    } else {
      setStatus("ä¸åŒ¹é…ï½", "bad");
playSfx("wrong.mp3");
      setTimeout(()=>{
        a.isFaceUp = false;
        b.isFaceUp = false;
        game.lockBoard = false;
        resetPicks();
        renderGrid();
      }, 900);
    }
  }

  function getPairsFromSelection(){
    const sel = vocabSelect.value;
    if (sel === "__builtin__") return builtinPairs.slice();
    return (sets[sel] || []).slice();
  }

  function startGame(){
    if (game && game.status === "playing") addCurrentGameTimeToCumulative();
    const diff = DIFF[difficulty.value] || DIFF.easy;
    const allPairs = getPairsFromSelection();

    if (allPairs.length < 2){
      setStatus("è¯åº“å¤ªå°‘ï¼šè¯·å…ˆå¯¼å…¥è‡³å°‘ 2 å¯¹è¯å†å¼€å§‹ã€‚", "bad");
      return;
    }

    let K = diff.pairs;
    if (allPairs.length < K) K = allPairs.length; // auto downgrade

    const picked = shuffle(allPairs.slice()).slice(0, K);
    const deck = buildDeck(picked);

    game = {
      status: "playing",
      layout: { rows: diff.rows, cols: diff.cols },
      totalPairs: K,
      deck,
      firstPick: null,
      secondPick: null,
      lockBoard: false,
      moves: 0,
      matches: 0,
      timeStart: Date.now(),
    };

    timeText.textContent = "0";
    setStatus(`å¼€å§‹ï¼å½“å‰ï¼š${difficulty.options[difficulty.selectedIndex].text}ï¼ˆå®é™…ä½¿ç”¨ ${K} å¯¹ï¼‰`);
    updateMeta();
    renderGrid();
    startTimer();
  }

  btnStart.onclick = startGame;
 btnRestart.onclick = ()=>{
  if (game && game.status === "playing") addCurrentGameTimeToCumulative();
  if (game) startGame();
};
  btnBackToMenu.onclick = () => {
  if (game && game.status === "playing") {
    const elapsed = Math.floor((Date.now() - game.timeStart) / 1000);

    // ç»“ç®—è¿›ç´¯è®¡ç”¨æ—¶ï¼ˆä½ ä¹‹å‰åŠ è¿‡è¿™ä¸ªå‡½æ•°ï¼‰
    addCurrentGameTimeToCumulative();

    // ç»“æŸæœ¬å±€å¹¶æ¸…ç©ºæœ¬å±€æ˜¾ç¤º
    stopTimer();
    setStatus(`æœ¬å±€å·²ç»“ç®—ï¼šç”¨æ—¶ ${elapsed}sï¼Œæ­¥æ•° ${game.moves}ï¼Œé…å¯¹ ${game.matches}/${game.totalPairs}ã€‚`, "ok");
  } else {
    setStatus("å½“å‰æ²¡æœ‰è¿›è¡Œä¸­çš„å¯¹å±€ï¼Œæ— éœ€ç»“ç®—ã€‚", "");
  }

  // å›åˆ°â€œå¼€å§‹è®¾ç½®â€çŠ¶æ€ï¼šæ¸…ç©ºæœ¬å±€æ•°æ®ä¸ç‰Œæ¡Œ
  game = null;
  timeText.textContent = "0";
  movesText.textContent = "0";
  matchText.textContent = "0";
  totalPairsText.textContent = "0";
  gridEl.innerHTML = "";

  // å¯é€‰ï¼šæŠŠé¡µé¢æ»šå›é¡¶éƒ¨ï¼ˆæ›´åƒâ€œå›åˆ°è®¾ç½®â€ï¼‰
  window.scrollTo({ top: 0, behavior: "smooth" });
};


  // ---------- Vocab management ----------
  btnUseSample.onclick = ()=>{
    importBox.value =
`apple - è‹¹æœ
rent\tç§Ÿé‡‘
menu - èœå•
receipt - æ”¶æ®
make a reservation - é¢„è®¢
deposit - æŠ¼é‡‘
interview - é¢è¯•
shift - ç­æ¬¡`;
  };

  btnParsePreview.onclick = ()=>{
    const {pairs, badLines} = parsePairs(importBox.value);
    previewText.textContent = `è§£æåˆ° ${pairs.length} å¯¹ï¼›æ— æ•ˆè¡Œ ${badLines.length} æ¡ã€‚`;
    if (badLines.length){
      setStatus("æœ‰éƒ¨åˆ†è¡Œæ— æ³•è§£æï¼šè¯·ç¡®è®¤ä½¿ç”¨ TAB æˆ– ' - ' åˆ†éš”ã€‚", "bad");
    } else {
      setStatus("è§£ææ­£å¸¸ï¼Œå¯ä»¥ä¿å­˜åˆ°è¯åº“ã€‚", "ok");
    }
  };

  btnSaveSet.onclick = ()=>{
    let name = (setSelect && setSelect.value !== "__new__") ? setSelect.value : setName.value.trim();
    if (!name){
      setStatus("è¯·å…ˆå¡«å†™è¯åº“åç§°ã€‚", "bad"); return;
    }
    const {pairs, badLines} = parsePairs(importBox.value);
    if (pairs.length < 2){
      setStatus("å¯¼å…¥å†…å®¹å¤ªå°‘ï¼šè‡³å°‘éœ€è¦ 2 å¯¹è¯ã€‚", "bad"); return;
    }
    sets[name] = pairs;
    saveSets(sets);
    refreshVocabSelect();
    refreshSetSelect();
    if (setSelect) setSelect.value = name;

    setStatus(`å·²ä¿å­˜è¯åº“ã€Œ${name}ã€ï¼Œå…± ${pairs.length} å¯¹ã€‚`, "ok");
    previewText.textContent = badLines.length ? `æç¤ºï¼šä»æœ‰ ${badLines.length} è¡Œæ— æ•ˆè¢«å¿½ç•¥ã€‚` : "";
  };

  btnDeleteSet.onclick = ()=>{
   const name = setSelect ? setSelect.value : setName.value.trim();
if (!name || name === "__new__" || !sets[name]) {
  setStatus("è¯·å…ˆåœ¨ä¸‹æ‹‰æ¡†é€‰æ‹©è¦åˆ é™¤çš„è¯åº“ã€‚", "bad");
  return;
}
    delete sets[name];
    saveSets(sets);
    refreshVocabSelect();
    refreshSetSelect();
    setStatus(`å·²åˆ é™¤è¯åº“ã€Œ${name}ã€ã€‚`, "ok");
  };
  // ---------- CSV file import ----------
  function parseSimpleCsv(text) {
    // ç®€åŒ–ç‰ˆCSVï¼šåªå–å‰ä¸¤åˆ— en,zhï¼ˆæ”¯æŒå¯é€‰è¡¨å¤´ï¼‰
    const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
    const pairs = [];
    let start = 0;

    if (lines[0]) {
      const first = lines[0].toLowerCase().replace(/\s+/g, "");
      if (first === "en,zh" || first === "english,chinese") start = 1;
    }

    for (let i = start; i < lines.length; i++) {
      const line = lines[i];
      const idx = line.indexOf(",");
      if (idx === -1) continue;

      const en = line.slice(0, idx).trim();
      const zh = line.slice(idx + 1).trim();

      if (en && zh) pairs.push({ en, zh });
    }
    return pairs;
  }

  if (btnLoadCsv) {
    btnLoadCsv.onclick = () => {
      const file = csvFile.files && csvFile.files[0];
      if (!file) { setStatus("è¯·å…ˆé€‰æ‹©ä¸€ä¸ª CSV æ–‡ä»¶ã€‚", "bad"); return; }

      const reader = new FileReader();
      reader.onload = () => {
        const text = String(reader.result || "");
        const pairs = parseSimpleCsv(text);

        if (!pairs.length) {
          setStatus("æ²¡è§£æåˆ°è¯å¯¹ï¼šè¯·ç¡®è®¤ CSV è‡³å°‘ä¸¤åˆ—ï¼ˆen,zhï¼‰ã€‚", "bad");
          return;
        }

        // è½¬æˆå¯¼å…¥æ¡†æœ€ç›´è§‚çš„æ ¼å¼ï¼ˆè‹±æ–‡ - ä¸­æ–‡ï¼‰
        importBox.value = pairs.map(p => `${p.en} - ${p.zh}`).join("\n");
        setStatus(`å·²è¯»å– CSVï¼šå…± ${pairs.length} å¯¹ã€‚ç°åœ¨ç‚¹â€œä¿å­˜/è¦†ç›–è¯åº“â€å³å¯ã€‚`, "ok");
        if (previewText) previewText.textContent = `å·²ä»CSVå¡«å…… ${pairs.length} å¯¹`;
      };
      reader.readAsText(file, "utf-8");
    };
  }

  // ---------- Backup / Share ----------
  function downloadText(filename, text, mime="application/json;charset=utf-8") {
    const blob = new Blob([text], { type: mime });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  async function copyToClipboard(text) {
    try {
      await navigator.clipboard.writeText(text);
      return true;
    } catch {
      const ta = document.createElement("textarea");
      ta.value = text;
      document.body.appendChild(ta);
      ta.select();
      try {
        document.execCommand("copy");
        ta.remove();
        return true;
      } catch {
        ta.remove();
        return false;
      }
    }
  }

  function exportAllCustomSetsJson() {
    const payload = { version: 1, sets };
    return JSON.stringify(payload, null, 2);
  }

  function exportCurrentSetTxt() {
  const name = (setSelect && setSelect.value !== "__new__") ? setSelect.value : setName.value.trim();
    if (!name) return { ok: false, msg: "è¯·å…ˆå¡«å†™è¦å¯¼å‡ºçš„è¯åº“åç§°ï¼ˆä¸Šé¢çš„è¯åº“åç§°æ¡†ï¼‰ã€‚" };
    if (!sets[name]) return { ok: false, msg: `æ‰¾ä¸åˆ°è¯åº“ã€Œ${name}ã€ã€‚è¯·ç¡®è®¤å·²ä¿å­˜è¯¥è¯åº“ã€‚` };
    const lines = sets[name].map(p => `${p.en} - ${p.zh}`);
    return { ok: true, text: lines.join("\n") };
  }

  if (btnExportAllJson) {
    btnExportAllJson.onclick = () => {
      const json = exportAllCustomSetsJson();
      exportBox.value = json;
      downloadText("vocab_sets.json", json);
      setStatus("å·²å¯¼å‡ºï¼šåŒæ—¶å·²ä¸‹è½½ vocab_sets.jsonï¼ˆä¹Ÿå¯å¤åˆ¶å‘é€ç»™åˆ«äººï¼‰ã€‚", "ok");
    };
  }

  if (btnExportCurrentTxt) {
    btnExportCurrentTxt.onclick = () => {
      const r = exportCurrentSetTxt();
      if (!r.ok) { setStatus(r.msg, "bad"); return; }
      exportBox.value = r.text;
      downloadText("vocab_set.txt", r.text, "text/plain;charset=utf-8");
      setStatus("å·²å¯¼å‡ºå½“å‰è¯åº“ TXTï¼ˆå¹¶ä¸‹è½½ vocab_set.txtï¼Œå¯å¤åˆ¶å‘é€ï¼‰ã€‚", "ok");
    };
  }

  if (btnCopyExport) {
    btnCopyExport.onclick = async () => {
      const text = (exportBox.value || "").trim();
      if (!text) { setStatus("å¯¼å‡ºæ¡†æ˜¯ç©ºçš„ï¼šè¯·å…ˆç‚¹å¯¼å‡ºæŒ‰é’®ã€‚", "bad"); return; }
      const ok = await copyToClipboard(text);
      setStatus(ok ? "å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ã€‚" : "å¤åˆ¶å¤±è´¥ï¼šè¯·æ‰‹åŠ¨å…¨é€‰å¯¼å‡ºæ¡†å†…å®¹å¤åˆ¶ã€‚", ok ? "ok" : "bad");
    };
  }

  if (btnImportShare) {
    btnImportShare.onclick = () => {
      const raw = (importShareBox.value || "").trim();
      if (!raw) { setStatus("è¯·å…ˆæŠŠ JSON ç²˜è´´åˆ°å¯¼å…¥æ¡†ã€‚", "bad"); return; }

      try {
        const obj = JSON.parse(raw);
        if (!obj || typeof obj !== "object" || !obj.sets || typeof obj.sets !== "object") {
          setStatus("JSON æ ¼å¼ä¸å¯¹ï¼šéœ€è¦åŒ…å« sets å­—æ®µï¼ˆä¾‹å¦‚ {version:1, sets:{...}}ï¼‰ã€‚", "bad");
          return;
        }

        const newSets = {};
        for (const [name, arr] of Object.entries(obj.sets)) {
          if (!Array.isArray(arr)) continue;
          const cleaned = [];
          for (const it of arr) {
            if (!it || typeof it !== "object") continue;
            const en = (it.en || "").toString().trim();
            const zh = (it.zh || "").toString().trim();
            if (en && zh) cleaned.push({ en, zh });
          }
          if (cleaned.length) newSets[name] = cleaned;
        }

        sets = newSets;
        saveSets(sets);
        refreshVocabSelect();
        setStatus("å¯¼å…¥æˆåŠŸï¼šå·²è¦†ç›–æœ¬æœºçš„è‡ªå®šä¹‰è¯åº“ã€‚å›åˆ°â€œå¼€å§‹æ¸¸æˆâ€é€‰æ‹©è¯åº“å³å¯ã€‚", "ok");
      } catch {
        setStatus("å¯¼å…¥å¤±è´¥ï¼šè¿™æ®µå†…å®¹ä¸æ˜¯åˆæ³• JSONã€‚", "bad");
      }
    };
  }

  // initial
  setStatus("æç¤ºï¼šå…ˆç”¨å†…ç½®è¯åº“è¯•ç©ï¼Œæˆ–å»ã€Œè¯åº“å¯¼å…¥ã€ç²˜è´´ä½ çš„è‹±æ–‡-ä¸­æ–‡ã€‚");
  refreshSetSelect();
  renderStats();
</script>
</body>
</html>
